<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>Îì±Î∞òÌòï Î°úÍ∑∏ÎùºÏù¥ÌÅ¨ Îßµ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      :root {
        font-family: 'Inter', 'Pretendard', system-ui, sans-serif;
        color: #f4f6ff;
        background: #07090f;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at 20% 0%, rgba(34, 64, 122, 0.45), rgba(2, 4, 9, 0.9));
      }

      #root {
        padding: 32px;
      }

      .app {
        max-width: 1080px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      header h1 {
        margin: 0;
        font-size: 28px;
      }

      header small {
        color: #9da9d6;
      }

      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        font-size: 13px;
      }

      .legend span {
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(118, 134, 185, 0.4);
        background: rgba(12, 18, 32, 0.7);
      }

      .resource-hud {
        position: fixed;
        left: 140px;
        bottom: 32px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        padding: 10px 14px;
        border-radius: 14px;
        background: rgba(8, 11, 19, 0.92);
        border: 1px solid rgba(98, 151, 255, 0.3);
        z-index: 60;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }

      .resource-tag {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        border-radius: 999px;
        background: rgba(14, 20, 33, 0.9);
        border: 1px solid rgba(84, 126, 194, 0.5);
        font-size: 13px;
      }

      .aether-column {
        position: fixed;
        left: 32px;
        top: 140px;
        width: 70px;
        padding: 10px;
        border-radius: 36px;
        background: linear-gradient(180deg, rgba(8, 12, 20, 0.95), rgba(10, 15, 25, 0.75));
        border: 1px solid rgba(96, 210, 255, 0.4);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.45);
        display: flex;
        flex-direction: column;
        gap: 12px;
        z-index: 55;
      }

      .aether-title {
        font-size: 13px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        text-align: center;
        color: #5fe0ff;
      }

      .aether-bar {
        position: relative;
        width: 46px;
        height: 260px;
        border-radius: 30px;
        border: 2px solid #53d7ff;
        margin: 0 auto;
        background: rgba(9, 17, 27, 0.95);
        overflow: hidden;
      }

      .aether-fill {
        position: absolute;
        left: 3px;
        right: 3px;
        bottom: 3px;
        border-radius: 24px;
        background: linear-gradient(180deg, #6affff 0%, #0f7ebd 100%);
        height: 0%;
        transition: height 0.2s ease;
      }

      .aether-remaining {
        text-align: center;
        color: #8fd3ff;
        font-size: 13px;
        line-height: 1.3;
      }

      .event-modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(1, 3, 8, 0.65);
        backdrop-filter: blur(6px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 80;
        padding: 20px;
      }

      .event-modal {
        width: min(440px, 100%);
        max-height: 85vh;
        overflow-y: auto;
        background: rgba(8, 11, 19, 0.98);
        border: 1px solid rgba(195, 115, 255, 0.35);
        border-radius: 18px;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 14px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
      }

      .event-modal h2 {
        margin: 0;
        font-size: 22px;
      }

      .event-modal p {
        margin: 0;
        color: #c9cfe7;
        line-height: 1.5;
      }

      .event-choices {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .choice-card {
        border: 1px solid rgba(118, 134, 185, 0.35);
        border-radius: 12px;
        padding: 12px;
        background: rgba(14, 18, 30, 0.85);
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .choice-card button {
        align-self: flex-start;
        padding: 6px 12px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        background: #4d7dff;
        color: white;
        font-weight: 600;
      }

      .choice-card button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .event-result {
        border-top: 1px solid rgba(255, 255, 255, 0.08);
        padding-top: 10px;
        color: #9ad1d6;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .risk-indicator {
        position: fixed;
        top: 24px;
        right: 24px;
        padding: 10px 16px;
        border-radius: 12px;
        background: rgba(7, 11, 18, 0.9);
        border: 1px solid rgba(255, 110, 135, 0.35);
        color: #ffe6ef;
        font-size: 13px;
        letter-spacing: 0.04em;
        z-index: 60;
      }

      .close-btn {
        align-self: flex-end;
        padding: 6px 12px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        background: #6c7bff;
        color: white;
        font-weight: 600;
      }

      .map {
        position: relative;
        min-height: 780px;
        border-radius: 18px;
        border: 1px solid rgba(109, 134, 181, 0.2);
        background: rgba(5, 8, 13, 0.92);
        overflow: hidden;
      }

      .node {
        position: absolute;
        width: 96px;
        height: 100px;
        border-radius: 18px;
        background: rgba(21, 27, 44, 0.95);
        border: 2px solid rgba(73, 92, 143, 0.6);
        color: inherit;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 6px;
        pointer-events: auto;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        font-size: 11px;
        transition: transform 0.16s, border 0.16s, background 0.16s;
      }

      .node .icon {
        font-size: 26px;
      }
      .node.selectable {
        cursor: pointer;
        border-color: #68c9ff;
        background: rgba(54, 72, 116, 0.85);
        box-shadow: 0 0 16px rgba(104, 201, 255, 0.45);
      }

      .node.selectable:hover {
        transform: translateY(-6px);
      }

      .node.cleared {
        border-color: #6ef19e;
        background: rgba(22, 52, 34, 0.9);
      }

      .node.boss {
        border-color: #ff5c8d;
      }

      .edge {
        position: absolute;
        pointer-events: none;
        overflow: visible;
      }

      .edge line {
        stroke: rgba(102, 148, 255, 0.35);
        stroke-width: 1.4;
        stroke-linecap: round;
        filter: drop-shadow(0 0 6px rgba(68, 107, 196, 0.25));
      }

      aside {
        background: rgba(6, 10, 18, 0.95);
        border: 1px solid rgba(104, 201, 255, 0.2);
        border-radius: 14px;
        padding: 18px;
      }

      aside h2 {
        margin-top: 0;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script>
      (function () {
        'use strict';

        const NODE_TYPES = ['battle', 'battle', 'event', 'shop', 'rest', 'elite'];
        const ICON_MAP = {
          battle: '‚öîÔ∏è',
          elite: 'üëπ',
          shop: 'üõí',
          event: '‚ùì',
          rest: 'üî•',
          boss: 'üíÄ',
          dungeon: 'üè∞',
        };
        const LEGEND = [
          { icon: '‚öîÔ∏è', label: 'Ï†ÑÌà¨' },
          { icon: 'üëπ', label: 'Ï†ïÏòà' },
          { icon: 'üè∞', label: 'ÎçòÏ†Ñ' },
          { icon: 'üõí', label: 'ÏÉÅÏ†ê' },
          { icon: '‚ùì', label: 'Ïù¥Î≤§Ìä∏' },
          { icon: 'üî•', label: 'Ìú¥Ïãù' },
          { icon: 'üíÄ', label: 'Î≥¥Ïä§' },
        ];
        const START_RESOURCES = { gold: 40, intel: 2, loot: 1, material: 1, aether: 5 };
        const PRAYER_COSTS = [1, 3, 5];
        const RESOURCE_LABELS = { gold: 'Í∏à', intel: 'Ï†ïÎ≥¥', loot: 'Ï†ÑÎ¶¨Ìíà', material: 'ÏõêÏûêÏû¨', aether: 'ÏóêÌÖåÎ•¥' };
        const TYPE_LABELS = {
          battle: 'BATTLE',
          elite: 'ELITE',
          shop: 'SHOP',
          event: '?',
          rest: 'REST',
          boss: 'BOSS',
          dungeon: 'DUNGEON',
        };
        const MAP_COLUMNS = 7;
        const MAP_LAYERS = 7;
        const MAP_MIN_NODES = 2;
        const MAP_MAX_NODES = 4;
        const MAP_WIDTH = 760;
        const V_SPACING = 140;
        const LAYER_TOP_OFFSET = 60;
        const NODE_WIDTH = 96;
        const NODE_HEIGHT = 100;
        const AETHER_DISPLAY_MAX = 10;
        const SVG_NS = 'http://www.w3.org/2000/svg';
        const EVENT_LIBRARY = {
          'event-entry-center': {
            title: 'ÌèêÌóàÍ∞Ä Îêú Î¨¥Í∏∞Í≥†',
            description: 'Î∂ïÍ¥¥Îêú ÏöîÏÉà ÏïàÏ™ΩÏóêÏÑú Í∏∞Í≥ÑÏùåÏù¥ ÏÉàÏñ¥ ÎÇòÏò®Îã§. Îπ†Î•¥Í≤å ÌÑ∏Í≥† ÎÇòÍ∞àÏßÄ, ÏúÑÌóòÏùÑ Í∞êÏàòÌï†ÏßÄ Í≤∞Ï†ïÌï¥Ïïº ÌïúÎã§.',
            choices: [
              {
                id: 'fight',
                label: 'Í∏∞Í≥ÑÎ≥ëÍ≥º Ï†ïÎ©¥ ÍµêÏ†Ñ',
                detail: 'Ï†ÑÌà¨Î°ú ÏûêÏõêÏùÑ ÌÉàÌôòÌïúÎã§. ÏúÑÌóòÌïòÏßÄÎßå Î≥¥ÏÉÅÏù¥ ÌÅ¨Îã§.',
                rewards: { loot: { min: 3, max: 5 }, gold: 20 },
                penalty: { loot: { min: 1, max: 2 }, gold: { min: 5, max: 10 } },
                successText: 'Í∏∞Í≥ÑÎ≥ëÏùÑ Í≤©ÌååÌïòÍ≥† Ï∞ΩÍ≥†Î•º ÌôïÎ≥¥ÌñàÎã§.',
                failureText: 'Í≤ΩÎ≥¥Í∞Ä Ïö∏Î†§ ÌîºÌï¥Îßå ÏûÖÍ≥† Ï≤†ÏàòÌñàÎã§.',
              },
              {
                id: 'stealth',
                label: 'Ïû†Ìñâ Ïπ®Ìà¨(Ï†ïÎ≥¥ 1)',
                detail: 'Ï†ïÎ≥¥Î•º ÏÜåÎ™®Ìï¥ Í≤ΩÎ≥¥Î•º ÎÅÑÍ≥† Ï°∞Ïö©Ìûà ÏïΩÌÉàÌïúÎã§.',
                cost: { intel: 1 },
                rewards: { loot: { min: 2, max: 3 } },
                penalty: { intel: 1 },
                successText: 'Í≤ΩÎ≥¥Î•º Ïö∏Î¶¨ÏßÄ ÏïäÍ≥† Î≥¥Í∏âÌíàÏùÑ Ï±ôÍ≤ºÎã§.',
                failureText: 'Í≤ΩÎπÑÎ≥ëÏóêÍ≤å Î∞úÍ∞ÅÎêòÏñ¥ Ï†ïÎ≥¥Îßå ÏûÉÍ≥† ÎèÑÎßùÏ≥§Îã§.',
              },
              {
                id: 'turret',
                label: 'Ìè¨ÌÉë Ìï¥Ï≤¥(ÏõêÏûêÏû¨ 2)',
                detail: 'Ìè¨ÌÉëÏùÑ Î∂ÑÌï¥Ìï¥ Î∞©Ïñ¥ Ïû•ÏπòÎ•º ÌöåÏàòÌïúÎã§.',
                cost: { material: 2 },
                rewards: { intel: 1, loot: 1 },
                penalty: { material: { min: 1, max: 2 } },
                successText: 'Ìè¨ÌÉëÏùÑ Í≥†Ï≤†Î°ú ÎßåÎì§Í≥† ÌöåÎ°ú ÏùºÎ∂ÄÎ•º Ïó∞Íµ¨ Îç∞Ïù¥ÌÑ∞Î°ú Ï†ÑÌôòÌñàÎã§.',
                failureText: 'Ìè¨ÌÉëÏù¥ Ìè≠Î∞úÌï¥ ÏûêÏû¨Îßå ÎÇ†Î†∏Îã§.',
              },
            ],
          },
          'event-mid-center': {
            title: 'Ïú†Îûë ÏÉÅÎã®',
            description: 'Ìô©Î¨¥ÏßÄÎ•º Îñ†ÎèÑÎäî Ïù¥Îèô ÏÉÅÎã®Ïù¥ ÍµêÏó≠ÏùÑ Ï†úÏïàÌïúÎã§. Ïã†Ïö©Î≥¥Îã§Îäî Ïã§Î¨ºÏùÑ ÏÑ†Ìò∏ÌïúÎã§.',
            choices: [
              {
                id: 'buy',
                label: 'Ïπ¥Îìú Íµ¨Îß§(Í∏à 30)',
                detail: 'Ïã†Ìòï Ïπ¥ÎìúÎ•º ÌôïÎ≥¥Ìï¥ Îç±ÏùÑ Í∞ïÌôîÌïúÎã§.',
                cost: { gold: 30 },
                rewards: { loot: 1, intel: 1 },
                penalty: { gold: { min: 5, max: 15 } },
                successText: 'ÏÉÅÏûêÎäî ÎπÑÏååÏßÄÎßå Ïã†Í∑ú Ï†ÑÏà† Ï†ïÎ≥¥Î•º ÏñªÏóàÎã§.',
                failureText: 'ÏÉÅÌíàÏù¥ Î∂àÎüâÏù¥Ïñ¥ÏÑú Ï∂îÍ∞Ä ÏàòÎ¶¨ÎπÑÎßå Îì§ÏóàÎã§.',
              },
              {
                id: 'shareIntel',
                label: 'Ï†ïÎ≥¥ ÍµêÌôò',
                detail: 'Ï†ïÎ≥¥ 2Î•º Í≥µÏú†ÌïòÍ≥† Îã§Ïùå Ï†ÑÌà¨Î•º ÎåÄÎπÑÌïúÎã§.',
                cost: { intel: 2 },
                rewards: { gold: 15, material: 1 },
                penalty: { gold: { min: 5, max: 10 } },
                successText: 'ÏÉÅÎã®ÏùÄ ÎåÄÍ∞ÄÎ°ú ÏûêÍ∏àÍ≥º ÏûêÏû¨Î•º ÎÇ¥Ï£ºÏóàÎã§.',
                failureText: 'Ï†ïÎ≥¥Í∞Ä Í∞ÄÏπò ÏóÜÏóàÎã§Î©∞ ÌóêÍ∞íÎßå Ï†úÏãúÌñàÎã§.',
              },
              {
                id: 'sellLoot',
                label: 'Ï†ÑÎ¶¨Ìíà ÌåêÎß§',
                detail: 'ÏßÄÍ∏àÍπåÏßÄ Î™®ÏùÄ Ï†ÑÎ¶¨ÌíàÏúºÎ°ú Í±∞ÎûòÌïúÎã§.',
                cost: { loot: 2 },
                rewards: { gold: 25 },
                penalty: { loot: 1 },
                successText: 'Ïû•ÎπÑÎ•º ÌåîÏïÑ Ïó¨Ïú† ÏûêÍ∏àÏùÑ ÌôïÎ≥¥ÌñàÎã§.',
                failureText: 'Íµ¨Îß§ÏûêÍ∞Ä ÏÇ¨ÎùºÏ†∏ Ï†ÑÎ¶¨Ìíà ÏùºÎ∂ÄÎßå ÎπºÏïóÍ≤ºÎã§.',
              },
            ],
          },
          'event-upper-right': {
            title: 'ÌèêÍ¥ëÏùò Ï∞®Ïõê Í∑†Ïó¥',
            description: 'ÌèêÍ¥ë ÏïàÏóêÏÑú ÏãúÍ≥µÏù¥ ÏùºÍ∑∏Îü¨ÏßÄÍ≥† ÏûàÎã§. Î¨¥ÏãúÌïòÎ©¥ Îçî Ïª§Ïßà Í≤É Í∞ôÎã§.',
            choices: [
              {
                id: 'investigate',
                label: 'Í∑†Ïó¥ Ï°∞ÏÇ¨(Ï†ïÎ≥¥ 2)',
                detail: 'Í∑†Ïó¥ Íµ¨Ï°∞Î•º Î∂ÑÏÑùÌï¥ Ï†ÑÎ¶¨ÌíàÏùÑ ÌôïÎ≥¥ÌïúÎã§.',
                cost: { intel: 2 },
                rewards: { loot: { min: 4, max: 6 } },
                penalty: { material: 1 },
                successText: 'ÏúÑÌóòÌñàÏßÄÎßå Í∑ÄÏ§ëÌïú ÏãúÎ£åÎ•º ÏñªÏóàÎã§.',
                failureText: 'Í∑†Ïó¥Ïù¥ Ìè≠Î∞úÌï¥ Ïû•ÎπÑÍ∞Ä ÏÜêÏÉÅÎêêÎã§.',
              },
              {
                id: 'seal',
                label: 'ÏõêÏûêÏû¨ 3ÏúºÎ°ú Î¥âÏù∏',
                detail: 'ÏûêÏû¨Î•º ÌÉúÏõå Í∑†Ïó¥ÏùÑ Î¥âÏù∏ÌïòÍ≥† ÏßÄÏó≠ÏùÑ ÏïàÏ†ïÌôîÌïúÎã§.',
                cost: { material: 3 },
                rewards: { gold: 25, intel: 1 },
                penalty: { material: { min: 2, max: 3 }, gold: 10 },
                successText: 'Í∑†Ïó¥Ïù¥ Î¥âÏù∏ÎêòÏñ¥ Í∏∏Ïù¥ ÏïàÏ†ÑÌï¥Ï°åÎã§.',
                failureText: 'Î¥âÏù∏ Ïã§Ìå®Î°ú ÏûêÏõêÎßå ÏÜåÎ™®ÌñàÎã§.',
              },
              {
                id: 'ignore',
                label: 'Î¨¥ÏãúÌïòÍ≥† ÏßÄÎÇòÏπòÍ∏∞',
                detail: 'ÏúÑÌóòÏùÑ Í∞êÏàòÌïòÏßÄ ÏïäÎäîÎã§.',
                rewards: {},
                penalty: { intel: 1 },
                successText: 'Í∑†Ïó¥ÏùÑ ÏßÄÎÇòÏ≥§ÏßÄÎßå Î∂àÍ∏∏Ìïú ÎäêÎÇåÏù¥ ÎÇ®ÏïòÎã§.',
                failureText: 'Í∑†Ïó¥ÏóêÏÑú ÎÇòÏò® Ìè≠Î∞úÏóê Ïû•ÎπÑÍ∞Ä ÏÜêÏÉÅÎêêÎã§.',
              },
            ],
          },
          'event-top-left': {
            title: 'Íµ¨Ï°∞ ÏöîÏ≤≠ Ïã†Ìò∏',
            description: 'ÏïΩÌïú Ïã†Ìò∏Í∞Ä Î∞òÎ≥µÏ†ÅÏúºÎ°ú ÏàòÏã†ÎêúÎã§. Ìï®Ï†ïÏùº ÏàòÎèÑ ÏûàÏßÄÎßå ÏÇ¨ÎûåÏù¥ Í∏∞Îã§Î¶¥ ÏàòÎèÑ ÏûàÎã§.',
            choices: [
              {
                id: 'rescue',
                label: 'Íµ¨Ï°∞ ÏûëÏ†Ñ',
                detail: 'Ï†ÑÌà¨Î•º ÏπòÎ•¥Í≥† ÏÉùÏ°¥ÏûêÎ•º ÌôïÎ≥¥ÌïúÎã§.',
                rewards: { intel: 2, loot: 1 },
                penalty: { loot: 1 },
                successText: 'ÏÉùÏ°¥ÏûêÎ•º Íµ¨Ï°∞ÌñàÍ≥† ÎèôÎ£åÏùò Ïã†Î¢∞Î•º ÏñªÏóàÎã§.',
                failureText: 'Ï†Å Îß§Î≥µÏúºÎ°ú Ï†ÑÎ¶¨ÌíàÎßå ÏûÉÏóàÎã§.',
              },
              {
                id: 'donation',
                label: 'Í∏à 20 Í∏∞Î∂Ä',
                detail: 'Î¨ºÏûêÎ•º ÏßÄÏõêÌïòÍ≥† ÌùîÏ†ÅÏùÑ ÎÇ®Í∏∞ÏßÄ ÏïäÎäîÎã§.',
                cost: { gold: 20 },
                rewards: { intel: 1 },
                penalty: { gold: 5 },
                successText: 'Í∞êÏÇ¨Ïùò ÌëúÏãúÎ°ú Ï†ïÎ≥¥ Ìå®ÌÇ∑ÏùÑ Î∞õÏïòÎã§.',
                failureText: 'ÏßÄÏõê Î¨ºÏûêÍ∞Ä ÏÇ¨ÎùºÏ†∏ Ï∂îÍ∞Ä Í∏àÏï°Îßå ÌóàÎπÑÌñàÎã§.',
              },
              {
                id: 'salvage',
                label: 'Ïã†Ìò∏ Ïû•ÎπÑ Îß§Í∞Å(Ï†ÑÎ¶¨Ìíà 1)',
                detail: 'Ïã†Ìò∏Í∏∞Î•º Î∂ÑÌï¥Ìï¥ ÏûêÍ∏àÏùÑ ÎßàÎ†®ÌïúÎã§.',
                cost: { loot: 1 },
                rewards: { gold: 15, material: 1 },
                penalty: { intel: 1 },
                successText: 'Ï∞®Í∞ëÏßÄÎßå Ïã§Ïö©Ï†ÅÏù∏ ÏÑ†ÌÉùÏù¥ÏóàÎã§.',
                failureText: 'Ïû•ÎπÑÍ∞Ä Ìè≠Ï£ºÌï¥ Ï†ïÎ≥¥Í∞Ä ÏÜåÏã§ÎêêÎã§.',
              },
            ],
          },
        };
        const EVENT_KEYS = Object.keys(EVENT_LIBRARY);

        function randomInt(min, max) {
          const low = Math.ceil(min);
          const high = Math.floor(max);
          return Math.floor(Math.random() * (high - low + 1)) + low;
        }

        function resolveAmount(value) {
          if (typeof value === 'number') return value;
          if (!value || typeof value !== 'object') return 0;
          const min = value.min ?? 0;
          const max = value.max ?? min;
          return randomInt(min, max);
        }

        function describeAmount(value) {
          if (value == null) return '0';
          if (typeof value === 'number') return `${value}`;
          const min = value.min ?? 0;
          const max = value.max ?? min;
          return min === max ? `${min}` : `${min}~${max}`;
        }

        function describeBundle(bundle = {}) {
          const entries = Object.entries(bundle);
          if (!entries.length) return 'ÏóÜÏùå';
          return entries
            .map(([key, value]) => `${RESOURCE_LABELS[key] ?? key} ${describeAmount(value)}`)
            .join(', ');
        }

        function describeCost(cost = {}) {
          const entries = Object.entries(cost);
          if (!entries.length) return 'ÏÜåÎ™® ÏóÜÏùå';
          return entries.map(([key, value]) => `${RESOURCE_LABELS[key] ?? key} ${value}`).join(', ');
        }

        function canAfford(cost = {}) {
          return Object.entries(cost).every(([key, value]) => (state.resources[key] ?? 0) >= value);
        }

        function payCost(cost = {}) {
          Object.entries(cost).forEach(([key, value]) => {
            state.resources[key] = Math.max(0, (state.resources[key] ?? 0) - value);
          });
        }

        function grantRewards(rewards = {}) {
          const applied = {};
          Object.entries(rewards).forEach(([key, value]) => {
            const amount = resolveAmount(value);
            state.resources[key] = (state.resources[key] ?? 0) + amount;
            applied[key] = amount;
          });
          return applied;
        }

        function applyPenalty(penalty = {}) {
          const applied = {};
          Object.entries(penalty).forEach(([key, value]) => {
            const amount = resolveAmount(value);
            const current = state.resources[key] ?? 0;
            const actual = Math.min(current, amount);
            state.resources[key] = Math.max(0, current - actual);
            applied[key] = -actual;
          });
          return applied;
        }

        function formatApplied(bundle = {}) {
          const entries = Object.entries(bundle);
          if (!entries.length) return 'Î≥ÄÌôî ÏóÜÏùå';
          return entries
            .map(([key, value]) => {
              const sign = value >= 0 ? '+' : '';
              return `${RESOURCE_LABELS[key] ?? key} ${sign}${value}`;
            })
            .join(', ');
        }

        function computeFriendlyChance(risk) {
          const clamped = Math.max(0, Math.min(100, risk));
          const base = 1 - clamped / 120;
          return Math.max(0.2, Math.min(0.85, base));
        }
        let state;

        function shuffle(list) {
          for (let i = list.length - 1; i > 0; i -= 1) {
            const j = Math.floor(Math.random() * (i + 1));
            [list[i], list[j]] = [list[j], list[i]];
          }
          return list;
        }

        function randomEventKey() {
          return EVENT_KEYS[Math.floor(Math.random() * EVENT_KEYS.length)];
        }

        function columnToX(column) {
          const step = MAP_WIDTH / (MAP_COLUMNS + 1);
          return step * (column + 1);
        }

        function layerToY(layerIdx) {
          const displayRow = MAP_LAYERS - 1 - layerIdx;
          return displayRow * V_SPACING + LAYER_TOP_OFFSET;
        }

        function nearestByColumn(nodes, column) {
          return nodes.reduce((closest, node) => {
            const diff = Math.abs(node.column - column);
            if (!closest || diff < closest.diff) {
              return { node, diff };
            }
            return closest;
          }, null).node;
        }

        function assignNodeTypes(nodes) {
          const startNode = nodes.find((n) => n.layer === 0);
          const bossNode = nodes.find((n) => n.layer === MAP_LAYERS - 1);
          startNode.type = 'event';
          startNode.isStart = true;
          bossNode.type = 'boss';

          const candidates = nodes.filter((n) => n !== startNode && n !== bossNode);
          shuffle(candidates);
          const eventTarget = Math.max(1, Math.round(candidates.length * 0.5));
          candidates.slice(0, eventTarget).forEach((node) => {
            node.type = 'event';
          });

          const remaining = candidates.slice(eventTarget);
          const pool = ['battle', 'battle', 'battle', 'rest', 'shop', 'elite', 'dungeon'];
          remaining.forEach((node) => {
            node.type = pool[Math.floor(Math.random() * pool.length)];
          });

          const dungeonCandidate = nodes.find((n) => n.type === 'dungeon');
          if (!dungeonCandidate) {
            const selectPool = nodes.filter((n) => !n.isStart && n.type !== 'boss');
            if (selectPool.length) {
              const chosen = selectPool[Math.floor(Math.random() * selectPool.length)];
              chosen.type = 'dungeon';
            }
          }

          nodes.forEach((node) => {
            if (node.type === 'event' && !node.isStart) {
              node.eventKey = randomEventKey();
            }
            if (node.isStart) {
              node.displayLabel = 'Start';
            } else if (node.type === 'event') {
              node.displayLabel = '?';
            } else {
              node.displayLabel = TYPE_LABELS[node.type] ?? node.type.toUpperCase();
            }
          });
        }

        function generateLayerColumns(layerIdx) {
          if (layerIdx === 0 || layerIdx === MAP_LAYERS - 1) {
            return [Math.floor(MAP_COLUMNS / 2)];
          }
          const count = randomInt(MAP_MIN_NODES, MAP_MAX_NODES);
          const options = shuffle(Array.from({ length: MAP_COLUMNS }, (_, i) => i));
          return options.slice(0, count).sort((a, b) => a - b);
        }

        function generateMap() {
          const layers = [];
          for (let layer = 0; layer < MAP_LAYERS; layer += 1) {
            const columns = generateLayerColumns(layer);
            const nodes = columns.map((column, index) => ({
              id: `L${layer}-N${index}`,
              layer,
              column,
              x: columnToX(column),
              y: layerToY(layer),
              type: 'battle',
              connections: [],
            }));
            layers.push(nodes);
          }

          for (let layer = 0; layer < MAP_LAYERS - 1; layer += 1) {
            const current = layers[layer];
            const next = layers[layer + 1];

            current.forEach((node) => {
              let targets = next.filter((candidate) => Math.abs(candidate.column - node.column) <= 1);
              if (!targets.length) {
                targets = [nearestByColumn(next, node.column)];
              }
              node.connections = targets.map((target) => target.id);
            });

            next.forEach((node) => {
              const inbound = current.some((prev) => prev.connections.includes(node.id));
              if (!inbound) {
                const fallback = nearestByColumn(current, node.column);
                fallback.connections.push(node.id);
              }
            });
          }

          const flatNodes = layers.flat();
          assignNodeTypes(flatNodes);
          flatNodes.forEach((node) => {
            node.cleared = node.layer === 0;
            node.selectable = node.layer === 1;
          });

          return {
            nodes: flatNodes,
            currentNodeId: flatNodes.find((node) => node.layer === 0).id,
          };
        }

        function getNodeById(nodes, id) {
          return nodes.find((node) => node.id === id);
        }

        function drawEdge(container, startNode, endNode) {
          const startX = startNode.x;
          const startY = startNode.y;
          const endX = endNode.x;
          const endY = endNode.y;

          const left = Math.min(startX, endX) - NODE_WIDTH / 2;
          const top = Math.min(startY, endY) - NODE_HEIGHT / 2;
          const width = Math.max(4, Math.abs(endX - startX) + NODE_WIDTH);
          const height = Math.max(4, Math.abs(endY - startY) + NODE_HEIGHT);

          const svg = document.createElementNS(SVG_NS, 'svg');
          svg.setAttribute('class', 'edge');
          svg.setAttribute('width', width);
          svg.setAttribute('height', height);
          svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
          svg.style.left = `${left}px`;
          svg.style.top = `${top}px`;

          const line = document.createElementNS(SVG_NS, 'line');
          line.setAttribute('x1', startX - left);
          line.setAttribute('y1', startY - top);
          line.setAttribute('x2', endX - left);
          line.setAttribute('y2', endY - top);
          svg.appendChild(line);
          container.appendChild(svg);
        }

        function createNodeButton(node) {
          const button = document.createElement('button');
          const classes = ['node', node.type];
          if (node.selectable && !node.cleared) classes.push('selectable');
          if (node.cleared) classes.push('cleared');
          button.className = classes.join(' ');
          button.style.left = `${node.x - NODE_WIDTH / 2}px`;
          button.style.top = `${node.y - NODE_HEIGHT / 2}px`;

          if (!node.isStart) {
            const icon = document.createElement('span');
            icon.className = 'icon';
            icon.textContent = ICON_MAP[node.type] ?? '';
            button.appendChild(icon);
          }

          const label = document.createElement('span');
          label.textContent = node.displayLabel ?? node.type;

          button.appendChild(label);
          button.addEventListener('click', () => travel(node.id));
          return button;
        }

        function triggerEvent(node) {
          if (!node || node.type !== 'event' || node.isStart) {
            state.activeEvent = null;
            return;
          }
          const key = node.eventKey || randomEventKey();
          const definition = EVENT_LIBRARY[key];
          if (!definition) {
            state.activeEvent = null;
            return;
          }
          const friendlyChance = computeFriendlyChance(state.mapRisk);
          state.activeEvent = {
            definition,
            resolved: false,
            outcome: null,
            risk: state.mapRisk,
            friendlyChance,
          };
        }

        function handleEventChoice(choiceId) {
          if (!state.activeEvent || state.activeEvent.resolved) return;
          const { definition, friendlyChance } = state.activeEvent;
          const choice = definition.choices.find((item) => item.id === choiceId);
          if (!choice || !canAfford(choice.cost || {})) return;

          payCost(choice.cost || {});

          const chance = friendlyChance ?? computeFriendlyChance(state.mapRisk);
          const isFriendly = Math.random() < chance;

          let rewards = {};
          let penalty = {};
          if (isFriendly) {
            rewards = grantRewards(choice.rewards || {});
          } else {
            penalty = applyPenalty(choice.penalty || {});
          }

          state.activeEvent.resolved = true;
          state.activeEvent.outcome = {
            choice: choice.label,
            success: isFriendly,
            text: isFriendly ? choice.successText : choice.failureText,
            cost: choice.cost || {},
            rewards,
            penalty,
            probability: chance,
          };
          render();
        }

        function invokePrayer(cost) {
          if (!state.activeEvent || state.activeEvent.resolved) return;
          const available = state.resources.aether ?? 0;
          if (available < cost) return;

          payCost({ aether: cost });
          const rewards = grantRewards({ intel: Math.max(1, Math.ceil(cost / 2)) });

          state.activeEvent.resolved = true;
          state.activeEvent.outcome = {
            choice: `Í∏∞ÎèÑ x${cost}`,
            success: true,
            text: 'ÏóêÌÖåÎ•¥Í∞Ä ÏùëÎãµÌïòÏó¨ ÏúÑÏÉÅÏù¥ Ï†ïÌôîÎêòÏóàÏäµÎãàÎã§.',
            cost: { aether: cost },
            rewards,
            penalty: {},
            probability: 1,
          };
          render();
        }

        function closeEventModal() {
          if (!state.activeEvent) return;
          state.activeEvent = null;
          render();
        }

        function travel(nodeId) {
          const nodes = state.map.nodes;
          const target = getNodeById(nodes, nodeId);
          if (!target || !target.selectable || target.cleared) return;

          nodes.forEach((node) => {
            if (!node.cleared) node.selectable = false;
          });

          target.cleared = true;
          state.map.currentNodeId = target.id;

          target.connections.forEach((id) => {
            const nextNode = getNodeById(nodes, id);
            if (nextNode && !nextNode.cleared) {
              nextNode.selectable = true;
            }
          });

          triggerEvent(target);
          render();
        }

        function renderLegend(parent) {
          const legend = document.createElement('div');
          legend.className = 'legend';
          LEGEND.forEach((item) => {
            const chip = document.createElement('span');
            chip.textContent = `${item.icon} ${item.label}`;
            legend.appendChild(chip);
          });
          parent.appendChild(legend);
        }

        function renderResourceHud(root) {
          const hud = document.createElement('div');
          hud.className = 'resource-hud';
          Object.entries(state.resources)
            .filter(([key]) => key !== 'aether')
            .forEach(([key, value]) => {
              const tag = document.createElement('span');
              tag.className = 'resource-tag';
              tag.textContent = `${RESOURCE_LABELS[key] ?? key}: ${value}`;
              hud.appendChild(tag);
            });
          root.appendChild(hud);
        }

        function renderAetherColumn(root) {
          const column = document.createElement('div');
          column.className = 'aether-column';
          const title = document.createElement('div');
          title.className = 'aether-title';
          title.textContent = 'ÏóêÌÖåÎ•¥';
          column.appendChild(title);

          const bar = document.createElement('div');
          bar.className = 'aether-bar';
          const fill = document.createElement('div');
          fill.className = 'aether-fill';
          const available = state.resources.aether ?? 0;
          const ratio = Math.max(0, Math.min(1, available / AETHER_DISPLAY_MAX));
          fill.style.height = `${ratio * 100}%`;
          bar.appendChild(fill);
          column.appendChild(bar);

          const remaining = document.createElement('div');
          remaining.className = 'aether-remaining';
          const ptLine = document.createElement('div');
          ptLine.textContent = `${available}pt`;
          const tierLine = document.createElement('div');
          tierLine.textContent = `x${available}`;
          remaining.appendChild(ptLine);
          remaining.appendChild(tierLine);
          column.appendChild(remaining);

          root.appendChild(column);
        }

        function renderRiskIndicator(root) {
          const indicator = document.createElement('div');
          indicator.className = 'risk-indicator';
          indicator.textContent = `ÏúÑÌóòÎèÑ ${state.mapRisk}%`;
          root.appendChild(indicator);
        }

        function renderEventModal(root) {
          if (!state.activeEvent) return;

          const overlay = document.createElement('div');
          overlay.className = 'event-modal-overlay';

          const modal = document.createElement('div');
          modal.className = 'event-modal';

          const { definition, resolved, outcome } = state.activeEvent;
          const title = document.createElement('h2');
          title.textContent = definition.title;
          const desc = document.createElement('p');
          desc.textContent = definition.description;
          modal.appendChild(title);
          modal.appendChild(desc);
          const riskInfo = document.createElement('small');
          const friendlyPercent = Math.round(state.activeEvent.friendlyChance * 100);
          riskInfo.textContent = `ÏúÑÌóòÎèÑ ${state.mapRisk}% ¬∑ Ïö∞Ìò∏ ÌôïÎ•† ${friendlyPercent}%`;
          modal.appendChild(riskInfo);

          if (!resolved) {
            const choices = document.createElement('div');
            choices.className = 'event-choices';
            definition.choices.forEach((choice) => {
              const card = document.createElement('div');
              card.className = 'choice-card';

              const name = document.createElement('strong');
              name.textContent = choice.label;
              const detail = document.createElement('p');
              detail.textContent = choice.detail;
              const costLine = document.createElement('small');
              costLine.textContent = `ÏÜåÎ™®: ${describeCost(choice.cost || {})}`;
              const rewardLine = document.createElement('small');
              rewardLine.textContent = `Î≥¥ÏÉÅ: ${describeBundle(choice.rewards || {})}`;
              const penaltyLine = document.createElement('small');
              penaltyLine.textContent = `Ïã§Ìå® Ïãú: ${describeBundle(choice.penalty || {})}`;
              const btn = document.createElement('button');
              btn.textContent = 'ÏÑ†ÌÉù';
              btn.disabled = !canAfford(choice.cost || {});
              btn.addEventListener('click', () => handleEventChoice(choice.id));

              card.appendChild(name);
              card.appendChild(detail);
              card.appendChild(costLine);
              card.appendChild(rewardLine);
              card.appendChild(penaltyLine);
              card.appendChild(btn);
              choices.appendChild(card);
            });
            modal.appendChild(choices);

            const availablePrayers = PRAYER_COSTS.filter((cost) => (state.resources.aether ?? 0) >= cost);
            if (availablePrayers.length) {
              const prayerBlock = document.createElement('div');
              prayerBlock.className = 'event-choices';
              availablePrayers.forEach((cost) => {
                const card = document.createElement('div');
                card.className = 'choice-card';

                const name = document.createElement('strong');
                name.textContent = `Í∏∞ÎèÑ (ÏóêÌÖåÎ•¥ x${cost})`;
                const detail = document.createElement('p');
                detail.textContent = 'ÏóêÌÖåÎ•¥Î•º ÌÉúÏõå ÏïàÏ†ÑÌïú Ï†ÑÍ∞úÎ•º Í∏∞ÏõêÌï©ÎãàÎã§.';
                const info = document.createElement('small');
                info.textContent = 'ÏÑ±Í≥µ Î≥¥Ïû• / Ï†ïÎ≥¥ ÏÜåÎüâ ÌöçÎìù';
                const btn = document.createElement('button');
                btn.textContent = 'Í∏∞ÎèÑ';
                btn.addEventListener('click', () => invokePrayer(cost));

                card.appendChild(name);
                card.appendChild(detail);
                card.appendChild(info);
                card.appendChild(btn);
                prayerBlock.appendChild(card);
              });
              modal.appendChild(prayerBlock);
            }
          } else if (outcome) {
            const result = document.createElement('div');
            result.className = 'event-result';
            const name = document.createElement('strong');
            name.textContent = outcome.choice;
            const status = document.createElement('p');
            status.textContent = outcome.success ? 'Ïö∞Ìò∏Ï†ÅÏù∏ Ï†ÑÍ∞ú' : 'ÎπÑÏö∞Ìò∏Ï†ÅÏù∏ Ï†ÑÍ∞ú';
            const text = document.createElement('p');
            text.textContent = outcome.text;
            const costLine = document.createElement('p');
            const spent = Object.fromEntries(Object.entries(outcome.cost || {}).map(([k, v]) => [k, -v]));
            costLine.textContent = `ÏÜåÎ™®: ${formatApplied(spent)}`;
            const rewardLine = document.createElement('p');
            rewardLine.textContent = `Î≥¥ÏÉÅ: ${formatApplied(outcome.rewards)}`;
            const penaltyLine = document.createElement('p');
            penaltyLine.textContent = `Ìå®ÎÑêÌã∞: ${formatApplied(outcome.penalty)}`;
            const closeBtn = document.createElement('button');
            closeBtn.className = 'close-btn';
            closeBtn.textContent = 'ÌôïÏù∏';
            closeBtn.addEventListener('click', closeEventModal);

            result.appendChild(name);
            result.appendChild(status);
            result.appendChild(text);
            result.appendChild(costLine);
            result.appendChild(rewardLine);
            result.appendChild(penaltyLine);
            result.appendChild(closeBtn);
            modal.appendChild(result);
          }

          overlay.appendChild(modal);
          root.appendChild(overlay);
        }

        function render() {
          const root = document.getElementById('root');
          root.innerHTML = '';

          const app = document.createElement('div');
          app.className = 'app';
          root.appendChild(app);

          const header = document.createElement('header');
          const title = document.createElement('h1');
          title.textContent = 'Î°úÍ∑∏ÎùºÏù¥ÌÅ¨ Í≤ΩÎ°ú ÏÑ†ÌÉù Îßµ';
          const subtitle = document.createElement('p');
          subtitle.textContent = `ÌòÑÏû¨ ÏúÑÏπò: ${state.map.currentNodeId}`;
          header.appendChild(title);
          header.appendChild(subtitle);
          renderLegend(header);
          app.appendChild(header);

          const mapSection = document.createElement('section');
          mapSection.className = 'map';
          const nodes = state.map.nodes;
          const maxY = Math.max(...nodes.map((node) => node.y), 0);
          mapSection.style.minHeight = `${maxY + NODE_HEIGHT + 60}px`;
          app.appendChild(mapSection);

          nodes.forEach((node) => {
            node.connections.forEach((targetId) => {
              const target = getNodeById(nodes, targetId);
              if (target) {
                drawEdge(mapSection, node, target);
              }
            });
          });

          nodes.forEach((node) => {
            const button = createNodeButton(node);
            mapSection.appendChild(button);
          });

          renderResourceHud(root);
          renderAetherColumn(root);
          renderRiskIndicator(root);
          renderEventModal(root);

          const aside = document.createElement('aside');
          const asideTitle = document.createElement('h2');
          asideTitle.textContent = 'Îã§Ïùå ÌôïÏû• ÏïÑÏù¥ÎîîÏñ¥';
          const list = document.createElement('ol');
          [
            'ÎÖ∏Îìú ÌÉÄÏûÖÎ≥Ñ Ï†ÑÌà¨/Ïù¥Î≤§Ìä∏ Îç∞Ïù¥ÌÑ∞ Ïó∞Í≤∞',
            'Ï†ïÏòà¬∑Ìú¥Ïãù ÏµúÏÜå Îì±Ïû• ÎπÑÏú® Ï†úÏïΩ Ï∂îÍ∞Ä',
            'ÏãúÎìú Í∏∞Î∞ò ÏÉùÏÑ±ÏúºÎ°ú Ïû¨ÌòÑ Í∞ÄÎä•Ìïú Îü∞ Í≥µÏú†',
            'ÎÖ∏Îìú Î≥¥ÏÉÅ(Ïπ¥Îìú/Ïú†Î¨º/ÌöåÎ≥µ) ÏÇ¨Ï†Ñ ÌôïÏ†ï',
            'Îßµ ÏÉÅÌÉúÎ•º ÏÑ∏Ïù¥Î∏å Îç∞Ïù¥ÌÑ∞Ïóê ÏßÅÎ†¨Ìôî',
          ].forEach((text) => {
            const item = document.createElement('li');
            item.textContent = text;
            list.appendChild(item);
          });
          aside.appendChild(asideTitle);
          aside.appendChild(list);
          app.appendChild(aside);
        }

        state = {
          map: generateMap(),
          mapRisk: Math.floor(Math.random() * 61) + 20,
          resources: { ...START_RESOURCES },
          activeEvent: null,
        };
        render();
      })();
    </script>
  </body>
</html>
